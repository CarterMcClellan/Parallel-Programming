#! /usr/bin/env python
"""
Autotuning System

output_gnuplot.py

A utility to convert CSV tuning results files into gnuplot PLT files.
These can be used by the gnuplot program to plot graphs of the testing process.

Usage:
./output_gnuplot.py results.csv results.plt

This process preserves the ordering of variables and possible values,
as given in the CSV file.
"""


# Command line arguments
from optparse import OptionParser
# Filename manipulation
import os
# Reading in csv file
from common import readCSV

def main():
    
    # Command Line Arguments
    # Read name of CSV file from command line
    
    usage = "\n%prog [options] results.csv results.plt\nWhere results.csv was generated by the auto-tuner\nand results.plt is a gnuplot file to be created."
    parser = OptionParser(usage=usage)
    
    parser.add_option("-r", "--reference", 
                        action="store", type="float", dest="reference",
                        help="Adds a 'reference' score line to the graph, showing how the tuner's results compare to a default score.",
                        metavar="SCORE")
    
    options, args = parser.parse_args()
    
    if(len(args) != 2):
        parser.error("Expected two arguments: a CSV log file and a PLT file to be created.")
    csv_file = args[0]
    plt_file = args[1]
    
    
    
    # Import the CSV data
    print "Reading '" + csv_file + "'"
    tests, vars, possValues, repeat = readCSV(csv_file)
    
    
        
    # Generate the gnuplot file
    print "Generating gnuplot script"
    plt_str = generatePLT(tests, vars, possValues, repeat, plt_file, options.reference)
    
    
    # Write it out
    print "Writing '" + plt_file + "'"
    with open(plt_file, 'w') as f:
        f.write(plt_str)
        
        
        
    # Done
    print "Done"
    print "There are some instructions for generating a png at the top of the file."
    










def generatePLT(tests, vars, possValues, repeat, filename_plt, reference):
    
    
    # Generate the PLT file, by filling in a template.
    
    # Substitutions must be made for the following:
    # filename, filename_png, suggested_width
    # xrange_upper, yrange_lower, yrange_upper,
    # xtics_settings, ytics_settings, 
    # main_graph_plot_commands, sub_graph_plot_commands
    # And the plot commands sections must contain the relevant DATA.
    
    plt_subst_dict = {}
    
    
    plt_subst_dict['filename'] = os.path.split(filename_plt)[1]
    plt_subst_dict['filename_png'] = os.path.splitext(os.path.split(filename_plt)[1])[0] + ".png"
    
    plt_subst_dict['suggested_width'] = str(max(800, int(round(len(tests)*14, -2))))
    
    plt_subst_dict['xrange_upper'] = len(tests) + 1
    
    
    # Get a list of ALL test scores (incl overall scores).
    allResults = [r for t in tests for r in t[2] if r != ''] + [t[3] for t in tests if t[3] != '']
    if allResults == []:
        return False # There were no successful tests!
    
    allResults = map(float, allResults)
    if reference is not None:
        allResults.append(reference)
    
    maxResult = max(allResults)
    minResult = min(allResults)
    resultRange = maxResult - minResult
    
    # yrange is 20% 'bigger' on each end than the range of the data.
    # This puts the data nicely in the middle.
    plt_subst_dict['yrange_upper'] = maxResult + resultRange*0.2
    
    if minResult >= 0:
        plt_subst_dict['yrange_lower'] = max(minResult - resultRange*0.2, 0) # If all reults are nonegative, the scale doesn't go below 0. 
    else:
        plt_subst_dict['yrange_lower'] = minResult - resultRange*0.2

    
    
    # We want xtics every 5 tests, beginning at 1.
    if len(tests) > 20:
        final_tic = len(tests) - (len(tests) % 5)
        plt_subst_dict['xtics_settings'] = """
set xtics 5, 5, %(final_tic)s
set xtics add ("" 1 1, "" 2 1, "" 3 1, "" 4 1)
set xtics add %(last_m_tics)s
set mxtics 5
"""         % { 
            'final_tic': final_tic,
            'last_m_tics': "(" + ", ".join(['"" ' + str(i) + " 1" for i in range(final_tic+1, len(tests)+1)]) + ")"
          }
    
    else:
        plt_subst_dict['xtics_settings'] = """
set xtics 1, 1, %(final_tic)s
"""         % {'final_tic': len(tests)}
    
    
    
    
    
    # We want ytics to be well spaced, at sensible points
    plt_subst_dict['ytics_settings'] = '' # Let them be automatic...
    
    
    
    
    # The reference line, if required
    if reference is not None:
        ref_line = [str(reference) + "with lines lt 1 lc rgb \"black\""]
    else:
        ref_line = []
    
    # For the main graph, plt the overall score as a bar, then the individual scores as points.
    plot_cmds = ["plot \"-\" using 1:2 with boxes lc rgb \"black\""] + \
                ["\"-\" using 1:2 with points pt 2 lc rgb \"black\""]*repeat + \
                ref_line
    
    plot_cmds = ", \\\n     ".join(plot_cmds) + "\n"
    
    # The data for overall score
    for t in tests:
        plot_cmds += str(t[0]) + ", " + str(t[3]) + "\n"
    plot_cmds += "e\n"
    
    # The individual scores
    for i in range(0, repeat):
        for t in tests:
            plot_cmds += str(t[0]) + ", " + str(t[2][i]) + "\n"
        plot_cmds += "e\n"
    
    
    
    plt_subst_dict['main_graph_plot_commands'] = plot_cmds
    
    
    
    # For the subgraphs, set the tics/labels, plot commads and data.
    plt_subst_dict['sub_graph_plot_commands'] = ''
    
    if len(vars) > 0: # Should be guaranteed by previous checks!
        
        # Old idea: each subgraph gets an equal amount of space
        #subgraph_height = round(0.5 / len(vars), 3)
        
        # New idea: each subgraph gets space according to how many variables it has.
        # if a variable has n values, it gets (n+1)* this base height.
        subgraph_var_height = round(0.5 / sum([len(possValues[v])+1 for v in vars]), 3)
        
        
        # Loop through all variables, the last one being a special case.
        # Generate the commands to plot the subgraphs.
        for i in range(len(vars)):
            
            this_subgraph_height = subgraph_var_height * (len(possValues[vars[i]])+1)
            this_subgraph_offset = 0.6 - sum([subgraph_var_height * (len(possValues[vars[j]])+1) for j in range(i+1)])
            
            this_subgraph_data = ''
            for t in tests:
                this_subgraph_data += str(t[0]) + ", " + str(possValues[vars[i]].index(str(t[1][vars[i]]))+1) + "\n"
            this_subgraph_data += "e\n"
            
            plt_subst_dict['sub_graph_plot_commands'] += """
# Plot the graph for variable %(var_name)s
set size 1, %(height)s
set origin 0,%(offset)s

set ylabel "%(var_name)s"
set yrange [0:%(yrange_upper)s]
set ytics %(ytics)s

%(final_graph_extras)s

plot "-" using 1:2 with points pt 2 lc rgb "black"
%(the_data)s


"""             % {
                'var_name': vars[i],
                'height': this_subgraph_height,
                'offset': this_subgraph_offset,
                'yrange_upper': len(possValues[vars[i]]) + 1,
                'ytics': "(" + ", ".join(['"' + val + '" ' + str(possValues[vars[i]].index(val)+1) for val in possValues[vars[i]]]) + ")",
                'the_data': this_subgraph_data,
                'final_graph_extras': """

set xlabel "Test No."
set xtics out
set xtics nomirror
set format x

%(xtics_settings)s

#set bmargin

""" % {'xtics_settings': plt_subst_dict['xtics_settings']} if i == len(vars)-1 else ''
              }
        
        
        
    
    
    
    
    plt_text = """# %(filename)s
# Automatically generated gnuplot file to display the results of testing.
# 
# For PNG output, use something like the following:
# $ gnuplot
# gnuplot> set terminal png large size %(suggested_width)s, 1200
# gnuplot> set output '%(filename_png)s'
# gnuplot> load '%(filename)s'
# gnuplot> exit
# 
# Alternatively, uncomment the two lines below and run:
# $ gnuplot %(filename)s
# 

reset

#set terminal png large size %(suggested_width)s, 1200
#set output '%(filename_png)s'


set datafile separator ","
set datafile missing ""

unset xlabel
set ylabel "Score"
unset key
set title "Tuning Results"



set xrange [0:%(xrange_upper)s]
set yrange [%(yrange_lower)s:%(yrange_upper)s]

set format x ""
%(xtics_settings)s

%(ytics_settings)s

set xtics nomirror
set ytics nomirror
set ytics out
set xtics in

set border 3


set lmargin 12





# MULTIPLOT
# The main graph above, smaller graphs below showing how the variables change.


set size 1,1
set origin 0,0
set multiplot





# Main graph gets 40%%, labels, tics etc at bottom get 10%%
# Remaining 50%% is divided evenly between the variables.


set size 1,0.4
set origin 0,0.6


set bmargin 0

set boxwidth 1
set style fill solid 0.2
set grid front
unset grid


%(main_graph_plot_commands)s




set border 27
set tmargin 0
unset xtics
unset title
set grid ytics lt 1 lc rgb "#cccccc"
set grid layerdefault
set grid noxtics


%(sub_graph_plot_commands)s


unset multiplot
reset

""" % plt_subst_dict
    
    
    
    
    return plt_text
    
    
    









if __name__ == "__main__":
    main()
    

